前端面试问题

## CSS

css水平、垂直居中的写法：

- 水平居中：
  - 行内元素：`text-align: center`
  - 块级元素：`margin:0 auto`
  - `position: absolute` + `left: 50%` + `transform: translateX(-50%)`
  - `display: flex` + `justify-content: center`
- 垂直居中：
  - 设置`line-height`等于`height`
  - `position: absolute` + `top: 50%` + `transform: translateY(-50%)`
  - `display: flex` + `align-items: center`
  - `display: table`(父标签设置属性) + `display: table-cell` + `vertical-align: middle`

块级元素（block element）

`<div>`、`<p>`、`<h1-h6>`、`<br>`、`<ol>`、`<ul>`

行内元素（inline element）

`<a>`、`<span>`、`<strong>`、`<b>`、`<em>`、`<i>`、`<img>`、`<input>`、`<select>`、`<button>`、`<code>`、`<label>`、`<textarea>`



1rem、1em、1vh、1px各自代表的含义？

> rem

rem是全部的长度都相对于根元素`<html>`元素。通常做法是给html元素设置一个字体大小，然后其他元素的长度单位就为rem。

> em（默认为16px）

- 子元素字体大小的em是相对于父元素字体大小
- 元素的width/height/padding/margin用em的话是相对于该元素的font-size

> vw/vh

全称是Viewport Width和Viewport Height，视窗的宽度和高度，相当于屏幕宽度和高度的1%，不过，处理宽度的时候%单位更合适，处理高度的话vh单位更好。

> px

px像素（Pixel）。相对长度单位。像素px是相对于显示器屏幕分辨率而言的。



画一条0.5px的直线？

```css
height: 1px;
transform: scale(0.5);
```



说一下盒模型？

> 盒模型是css中重要的基础知识，也是必考的基础知识

盒模型的组成，由里向外content、paddin、border、margin。

在IE盒子模型中，width表示content+padding+border这三部分的宽度

在标准的盒子模型中，width指content部分的宽度

box-sizing的使用

```css
box-sizing: content-box 是W3C盒子模型
box-sizing: border-box 是IE盒子模型
```

box-sizing的默认属性是content-box



画一个三角形？

```css
.a {
    width: 0;
    height: 0;
    border: 100px solid transparent;
    border-bottom-color: #ed1250;
    margin: 20px auto;
}

<div class="a"></div>
```



正方形变成圆形

```css
.div_circle {
    width: 600px;
    height: 600px;
	background-color: blue;
    border-radius: 50%;
}
```



超宽文本替换为省略号

```css
<!-- 单行文本 -->
<style>
	/*
		1、设置宽度    width;
		2、强制文本在一行内显示   white-space: nowrap; 
		3、隐藏溢出内容    overflow: hidden;
		4、溢出进行省略    text-overflow: ellipsis;
	*/
    .div_single {
		height: 200px;
        width: 500px;
        border: 5px dotted blue;
        color: lightblue;
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
    }
</style>

```



水平居中

> 普通流inline

text-align: center;

```css
<style>
	/*
		块级元素中文本直接使用text-align实现水平居中
		行内元素可以使用一个块级的父元素包裹使用text-align实现文本水平居中
	*/
</style>
```

> 普通流block

margin: 0 auto;

```css
<style>
	/*
		margin: 0 auto;是相对于父元素的宽度居中
	*/
</style>
```

> 浮动元素

浮动元素脱离文档流

```css
<style>
    #square {
		height: 200px;
        width: 200px;
        background: gold;
        float: left;
        position: relative;
        left: 50%;
        margin-left: -100px;
        /* transform: translateX(-50%); */ /* css3中新添需考虑兼容性问题 */
    }
</style>
```

> 绝对定位

position: absolute;

```css
<style>
    span {
		color: gold;
        width: 120px;
        background: lightgrey;
        position: absolute;
        left: 0;
        right: 0;
        /* margin: 0 auto; */
        left: 50%;
        /* transform: translateX(-50%); */
        margin-left: -60px;
    }
</style>
```



清除浮动（浮动坍塌）

> clear

```css
<style>
    div span {
		display: inline-block;
        width: 25%;
        float: left;
    }
	/* 此处p标签为所有浮动元素后的空标签，用来清除浮动 */
    div p {
		color: white;
        text-align: center;
        clear: both;
    }
/* 会产生大量的空元素，浪费资源 */
</style>
```

> BFC

创建BFC解决浮动坍塌

```css
<style>
	/* 父元素设置为BFC */
    div {
		width: 300px;
        padding: 10px;
        background: #fae8c8;
        overflow: hidden;
        /* float: left */
    }
    div span {
		display: inline-block;
        width: 25%;
        float: left;
    }
</style>
```

> 伪元素（最为推荐）

```css
<style>
    div span {
		display: inline-block;
        width: 25%;
        float: left;
    }
	/* 父元素样式 */
    .clearfix::after {
		content: '';
        display: block;
        clear: both;
    }
</style>
```

 

外边距塌陷

垂直方向、块级元素

设置为新的BFC

##### 要求

- float属性的值不为none
- position属性的值不为static或relative 
- overflow属性的值不为visible
- display属性的值为flex，inline-flex，inline-block，table-cell或table-caption

```css
<style>
    .div_3 {
        height: 100px;
        width: 400px;
        background: red;
    }
    .div_1 {
        height: 100px;
        width: 400px;
        background: lightblue;
        text-align: center;
        margin-top: 10px;
    }
	/* 将div_2设置为行内块元素，这样解决 */
    .div_2 {
        height: 20px;
        width: 400px;
        background: lightgrey;
        text-align: center;
        display: inline-block;
        margin-top: 20px;
        /* float: left;
        margin-top: 20px; */
        /* position: absolute;
        margin-top: 20px; */
        /* 设置为相对定位，在原基础上移动，故不能使用margin-top，依然会造成塌陷 */
        /* position: relative;
        top: 20px; */
    }
</style>
<body>
	<div class="div_3">元素C</div>
	<div class="div_1">
		<div class="div_2">元素B</div>
	</div>
</body>
```



line-height属性

> line-height就是基线到基线的距离
>
> 行距 = line-height - font-size

通常文本上方和下方空格区域为半边距



垂直居中

> padding

```html
<div>
    <span>内容</span>
</div>
<style>
    div {
        width: 200px;
        padding-top: 50px;
        padding-bottom: 50px;
    }
    span {
        font-size: 50px;
    }
    /* 
    	优点：简单，只需设置上下内边距
    	缺点：父元素不能设置固定高度
    */
</style>
```

> line-height

```html
<div>
    <span>内容</span>
    <!-- p标签浏览器设置了margin，垂直居中需要设置margin: 0; -->
</div>
<style>
    div {
        width: 200px;
        height: 100px;
    }
    span {
        line-height: 100px;
    }
    /*
    	优点：可设置父元素固定高度
    	缺点：不太适合多行文字
    */
</style>
```

> Flexbox

```html
<div>
    <span>内容</span>
    <!-- p标签浏览器设置了margin，垂直居中需要设置margin: 0; -->
</div>
<style>
    div {
        width: 200px;
        height: 100px;
        display: flex;
        flex-direction: column;
        justify-content: center;
    }
    /*
    	优点：简单易懂
    	缺点：兼容性
    */
</style>
```

> table

```html
<body>
    <ul>
    	<li>1</li>
        <li>2</li>
        <li>3</li>
        <li>4</li>
        <li>5</li>
    </ul>
</body>
<style>
    ul {
        display: table;
    }
    li {
        display: table-cell;
        vertical-align: middle;
    }
</style>
```

> grid

```html
<body>
    <ul>
    	<li>1</li>
        <li>2</li>
        <li>3</li>
        <li>4</li>
        <li>5</li>
    </ul>
</body>
<style>
    ul {
        display: grid;
        grid-template-colums: repeat(6, 1fr);
        align-items: center;
        justify-content: center;
    }
</style>
```

> absolute

```html
<body>
    <div>
        <i></i>
    </div>
</body>
<style>
    div {
        position: relative;
    }
    i {
        height: 50px;
        width:50px;
        position: absolute;
        top: 50%;
        transform: translateY(-50%);
    }
</style>
```

> 伪元素

```html
<body>
    <div class="main">
        <div class="search">
            <form action="">
                <input type="text" placeholder="内容">
                <div class="button"><i></i></div>
            </form>
        </div>
    </div>
</body>
<style>
    div.search {
        display: inline-block;
        vertical-align: middle;
    }
    div.main::after {
        content: "";
        display: inline-block;
        background-color: gold;
        height: 100%;
        width: 0;
        vertical-align: middle;
    }
</style>
```



href和src的区别

> href是元素或文档与自定资源联通，是引用；src是下载后嵌入构成文档直接内容。



## JS

### Math对象

- `Math.floor( ): 向下取整`
- `Math.random( ): 0-1的随机数`
- `Math.abs( ): 绝对值`
- `Math.sqrt(9): 开方`
- `Math.pow(2, 4): 乘方`

0 - num之间随机整数：`Math.floor(Math.random * num + 1)`



### Date对象

> `var d = new Date();` 或者 `var d = new Date("2020-2-2")`

- `d.getFullYear();获取年份`
- `d.getMonth();获取月份`
- `d.getDate();获取日期`
- `d.getHours();获取小时`
- `d.getMinutes();获取分钟`
- `d.getMoSeconds();获取秒`
- `d.getTime();时间戳是指格林威治时间1970年01月01日00时00分00秒至现在的总毫秒数`

 

### 计时器方法`setInterval`

> `setInterval(function(){}, ms);`



### 正则表达式对象

> `var reg = new RegExp("123");` 或者 `var reg = /123/i;`
>
> 修饰符：`i: 执行对大小写不敏感的匹配`、`g: 执行全局匹配（查找所有匹配而非在找到第一个匹配后停止）`、`m: 执行多行匹配`

正则表达式的语法

一般情况下`*`、`+`、`?`、`{n,}`、`x{n,m}`都具有贪婪性质，可以通过后面加？变成非贪婪模式。

- `^: 开头`
- `$: 结尾`
- `[]: 范围，eg: [a-z]、[a-z0-9]`
- `{}: 位数,eg: {2}、{1,3}(1位到3位)、{1,}`
- `(): 分组`
- `+: 匹配一位或多位，同{1,}`
- `?: 0位或1位，同{0,1}`
- `*: 0位或多位，同{0,}`
- `.: 匹配所有`
- `\: 转义`
- `\d: 数字`
- `\w: 数字、字母、下划线`
- `\s: 空格或换行`
- `|: 匹配不同模式的正则匹配，eg: /^[a-z]{2}|[0-9]{3}$/ 匹配两个小写字母或者三个数字`

正则表达式通常用于match个字符串方法：`search()`、`replace()`和`match()`

```javascript
var str = "1234567";
// search()方法
var n = str.search(/345/i);	// 2

// replace()方法
var str_reg = str.replace(/345/i, "abc");	// 12abc67

// match()方法
var arr = str.match(/\d/g);	// ['1', '2', '3', '4', '5', '6', '7']
```

RegExp对象方法`test()`、`exec()`

> `test()`方法用于检测一个字符串是否匹配某个正则表达式，返回布尔值。

```js
var reg = /[a-z]/;
var result = reg.test("1234abcd");	// true
```



> `exec()`方法用来检索字符串中的正则表达式的匹配，返回数组，其中存放匹配的结果，可使用()分组。

```js
var reg = /[a-z]{2}|[0-9]{3}/g;
var arr = reg.exec("1a2bc3def4567s");	// ["bc", index: 3, ...]
var arr = reg.exec("1a2bc3def4567s");	// ['de', index: 6, ...]
var arr = reg.exec("1a2bc3def4567s");	// ['456', index: 9, ...]
```

区别：全局匹配时，match()会返回所有匹配上的内容；而exec()仅匹配单次匹配上的内容

全局匹配且进行多次匹配时，exec会从上次匹配结束的下一位开始匹配，返回本次匹配上的内容，直至无可以匹配的内容，返回null



### 解构赋值

> 数组解构赋值

```js
let [n, m] = [10, 20];
// 数据交换
[n, m] = [m, n];
```

> 对象解构赋值

```js
let {name, age} = {name: "小明", age: 18};
```



### prototype

> 可以使用prototype，通过原型对象为构造函数生成的对象赋予新的属性或方法。

```js
function Animal(name) {
    this.name = name;
}
Animal.prototype.sayhello = function() {
    console.log("hello!")
}
function Dog(name, age) {
    this.name = name;
    this.age = age;
}
Dog.prototype.sayName = function() {
    console.log(`我的名字是${this.name}`);
}
// 继承
Dog.prototype = new Animal();

var dog = new Dog("二哈"， 3);
dog.sayName();	// 我的名字是二哈
dog.sayHello();	// hello!
```



### DOM

#### 获取节点

- `document.getElementById();`
- `document.getElementsByClassName();`
- `document.querySelector();`
- `document.querySelectorAll();`

`domObject.innerHTML: 获取元素内的所有内容。`



#### 事件类型

- `window.unload: 事件在用户退出页面时发生`
- `.onblur: 失去焦点发生变化`
- `.onfocus: 点击文本框会获得焦点发生`
- `.onselect: 要选中文本框中的内容会执行的事件`
- `.onchange: 事件会在域的内容发生改变时发生`
- `.onreset: 当点击重置的时候才会发生`
- `.onsubmit: 点击提交`
- `.onresize: 当窗口发生大小变换的时候执行`
- `.ondbclick: 双击发生变化`
- `.onclick: 点击发生变化`
- `.onmouseover: 鼠标经过会发生变化，类似hover效果`
- `.onmouseenter: 鼠标移入执行`
- `.onmouseleave: 鼠标移出执行`



#### 设置样式

> element.style.xxx



#### 节点操作

- `document.createElement(): 创建元素节点`
- `document.createTextNode(): 创建文本节点`
- `document.appendChild(): 添加节点`
- `document.removeChild(): 删除节点`



#### 事件对象  

事件监听函数的形参可以获取事件对象。

通过事件对象可以获取鼠标坐标。

> 获取x坐标：e.clientX
>
> 获取y坐标：e.clientY



### 事件

#### 事件绑定

> 1. `addEventListener("eventType", func)`
> 2. `element.onEventType = func`

区别：

1. addEventListener在同一元素上的同一事件类型添加多个事件，不会被覆盖，而onEventType会覆盖。
2. addEventListener可以设置第三个参数决定元素在捕获阶段触发事件，而onEventType不能。



#### 事件流

> 事件捕获：从外层到内层
>
> 事件冒泡：从内层到外层

addEventListener的第三个参数（false：事件在冒泡阶段触发；true：时间在捕获阶段触发）



#### 阻止事件冒泡

接收事件对象event，在触发事件中添加`event.stopPropagation()`



#### 阻止事件的默认行为

添加`event.preventDefault()`，例如a标签阻止跳转，或在触发事件中`return false`



#### 事件委托

> 通过`event.target`获取子元素交给父元素触发事件执行。



#### 事件类型



location.href = url	网页跳转

window.onscroll事件：滚动条滚动事件

document.documentElement.scrollTop：页面滚动位置距离顶部距离

window.scrollTo(0, 0)：让页面滚动条返回至顶部



### BOM

- window对象（全局对象）
- screen对象包含有关用户屏幕的信息
- location对象用于获得当前页面的地址（url），并把浏览器重定向到新的页面
- history对象包含浏览器的历史
- navigator对象包含有关访问者浏览器的信息

#### window对象

> window对象是全局对象，所有在浏览器中可以直接使用的方法，都是window对象的方法。

1. 计时器方法

2. 弹出框方法

   `alert()`、`let str = prompt("提示信息", "默认显示")`、`let result = confirm("提示信息");`



#### location对象

1. `location.href - 属性返回当前页面的URL`
2. `location.hostname - 主机的域名`
3. `location.pathname - 当前页面的路径和文件名`
4. `location.port - 端口`
5. `location.protocol - 协议`



#### navigator对象

> navigator.userAgent：检查当前设备，并在控制台输出



#### 原生数据和引用数据

> 原生数据：number、string、undefined、object（null）、boolean
>
> 引用数据：Date()、RegExp()、Array()

原生数据，赋值给另一变量相当于在内存栈开辟新的内存空间；引用数据，赋值给另一变量相当于内存堆中开辟的同一内存空间，两变量都指向同一内存空间。



### js面试题

#### 对象克隆

> 浅拷贝：只能拷贝浅层次的原生数据，深层次的引用数据无法实现拷贝
>
> 深拷贝：

```js
// 浅拷贝
function copyObject(obj) {
    let newObj = {};
    for (let i in obj) {
        newObj[i] = obj[i];
    }
    return newObj;
}
```

```js
// 深拷贝（使用递归）
function copyObject(obj) {
    let newObj = {};
    for (let i in obj) {
        if (obj[i] instanceof Object) {
            newObj[i] = copyObject(obj[i]);
        } else {
            newObj[i] = obj[i];
        }
    }
    return newObj;
}
// 深拷贝（使用JSON）
function copyObject(obj) {
    let obj_json = JSON.stringity(obj);
    let newObj = JSON.parse(obj_json);
    
    return newObj;
}
```



#### 包装对象

> `new String()`、`new Number()`、`new Boolean()`

在使用`.toString()`、`.split()`、`.length`时，系统会自动将原始数据包装成对象，调用对象的方法，返回结果后销毁包装对象。

**因为null和undefined没有包装对象，所以无法使用`.toString()`转换位字符串类型，只能通过`String()`转换。**



#### this关键字的指向问题

1. 全局环境下指向全局对象
2. 全局函数中的this，指向全局对象
3. 内部函数中的this，指向调用方法的对象
4. 方法中的this，指向调用方法的对象
5. 事件中的this，指向触发事件的DOM对象
6. 构造函数中的this，指向new创建的对象
7. 箭头函数中的this，指向定义函数上下文的this



#### call、apply、bind方法

> 1. call，会调用函数，通过参数列表依次传参
> 2. apply，会调用函数，是通过数组来传递参数
> 3. bind，不会调用函数，将新的重新绑定this的函数作为返回值，通过参数列表依次传参

```js
function func() {
    console.log(this);	// 常规来说是window对象，但使用func.call(cat)后，this变成cat对象
}

let cat = {
    name: "miaomiao"
}
func.call(cat); 

// call方法实现多重 继承
function User() {
    this.crudContent = function() {
        console.log("User中方法调用");
    }
}；
function Admin() {
    User.call(this);
}

let admin = Admin()
admin.crudContent();	// User中方法调用
```



## jQuery

jQuery是一个基于JavaScript的库，主要用于操作DOM。

1. 获取节点`$("选择器")`
2. 操作节点`$().method()`
3. 设置元素样式`$().css()`

### $的作用

1. $其实就是一个函数名，是jQuery的缩写。
2. $可以作为选择器，获取DOM对象对应的jQuery对象。
3. $可以将一个dom对象，转换成一个jQuery对象。
4. 事件中的this，指向DOM对象，所以需要使用$(this)做转换。
5. 本质上jQuery就是js，只是我们可以使用一些现成的方法而已。



### jQuery常用方法

1. `.index(): 获取元素索引`
2. `.text(): 获取和设置文本节点`
3. `.css(): 获取和设置样式`
4. `.val(): 获取和设置value属性`
5. `.attr(): 获取和设置属性值，例如src`
6. `.addClass(): 添加class`
7. `.removeClass(): 删除class`
8. `.toggleClass(): 切换class`
9. `.siblings(): 获取同级其他元素`
10. `.find("选择器"): 获取子级`
11. `.parent(): 获取父级`



### DOM操作

- `$("<li></li>"): 创建封装DOM的jQuery对象`
- `.append(): 添加`
- `.remove(): 删除`

jQuery的事件委托

```js
$(".fruit-list").on("click", "li", function() {
    $(this).remove();
})
```



### jQuery事件

1. `click()`
2. `mouseenter()`
3. `mouseleave()`
4. `mousemove`
5. `on()事件委托`

可以进行链式操作，因为每个事件操作返回的都是自己。

```js
$(".box").click(function() {
	xxx;
}).mouseenter(function() {
    xxx;
}).mouseleave(function() {
    xxx;
}).mousemove(function(e) {
   xxx;
   letx = e.pageX;	// 类似于原生e.clientX
});
```



### jQuery动画方法

1. `show(500): 总执行时间500ms`
2. `hide(xxx)`
3. `fadeIn(xxx)`
4. `fadeOut(xxx)`
5. `slideDown(xxx)`
6. `slideUp(xxx)`
7. `animate(xxx)`



## Nodejs

> node项目创建，`npm init`，会生成一个`package.json`，在该项目的文件夹内使用npm安装第三方模块，后面添加--save，会将模块的信息添加进`package.json`，然后在部署之后，使用`npm install`，即可以下载项目使用的第三方模块。

### koa框架使用

```js
const Koa = require("koa"); // 引用Koa构造函数
const router = require("koa-router")(); // 引入并执行koa-router
const static = require("koa-static");	// 方便访问服务器静态资源
const views = require("koa-views");		// 使用render渲染html
const nunjucks = require("nunjucks");	// 解析html模板使用，例如传入数据，或者使用{% xxx %}
const parser = require("koa-parser");   // 解析post传输的数据
const session = require("koa-session");
const app = new Koa();  // 创建应用

app.keys = ["abasufhgakshfaf"];	// session加密
const port_num = 3000
app.use(parser());
app.use(session({
    maxAge: 10*1000		// session最长保存时间
}, app));

// 引入一个中间件，中间件即是一个函数
// app.use(async (ctx)=> {
//     ctx.body = "hello Koa!"
// })

app.use(static(__dirname + "/static"))
app.use(views(__dirname + "/views", {
    map: {html: "nunjucks"}
}))

router.get("/", async (ctx)=> {
    ctx.body = `
        <h1>首页标题</h1>
        <p>这个是首页内容</p>
        <img src="/images/idol.jpg", alt="">
    `
})

router.get("/nunjucks", async (ctx)=> {
    await ctx.render("index", {title: "hello nunjucks"});
})

router.get("/login", async (ctx)=> {
    // 接收get请求的query
    let name = ctx.query.name;
    let sex = ctx.query.sex;
    let isLogin = false;
    /* 
        ctx.cookies.set("username", "admin", {
            maxAge: 2000    // 设置cookie过期时间为2s
        }) 
    */
    await ctx.render("login", {
        name,
        sex,
    });
})
// 接收post的请求数据
// router.post("/login", async ctx=> {
//     let name = ctx.request.body.name;
//     let sex = ctx.request.body.sex;
//     await ctx.render("login", {
//         name,
//         sex
//     });
// })

router.put("/putData/:id", ctx=> {
    let id = ctx.params.id;
})

router.get("/session_get", async ctx=> {
    let name = ctx.session["user"];
    // ctx.redirect("./login")  // 重定向，跳转页面login
    ctx.body = name;
})

app.use(router.routes());   // 在koa项目中引用router


app.listen(port_num, ()=> {
    console.log(`server is runing at port ${port_num}`);
})  // 设置监听端口
```

使用`ctx.query.xxx`获得query（get方法）传送的数据；（url类似路径名后加上`?data1=xxx&data2=xxx`）

使用`ctx.request.body.xxx`获得post传送的数据；（post传送数据不在url中进行修改，需要导入koa-parser解析）

使用`ctx.params.xxx`获得params传送的数据；(url类似路径名后加上`/xxx/xxx`，路由配置的url后面添加类似的（`/:data1/:data2`）)



### ajax使用：

```js
let xhr = new XMLHttpRequest();
xhr.open(method, url);	// method为方法: get、post、put、delete; url为请求路径
xhr.send();
xhr.onreadystatechange = function() {
    if (xhr.readyState === 4 && xhr.status === 200) {
        console.log(xhr.responseText);	// xhr.responseText为接收到的json类型数据
    }
}
```



### axios对ajax的封装：

```js
import axios
axios.get("/url").then(res=> {
    console.log(res);	// axios.get(url)返回的是一个promise对象
})
axios.post("/url", {
    data1: xxx,
    data2: xxx
}).then(res=> {
    console.log(res);
})
axios.put("/url/1"),then(res=> {
    console.log(res);
})
axios.delete("/url/0").then(res=> {
    console.log(res);
})
```



### jQuery中的ajax:

```js
$.ajax({
	url: "/url",
    type: "post",
    data: "username=chen&nickname=alien",	// 可以使用query形式或者直接将数据填入或JSON.stringify
    dataType: "json"	// 指定响应的数据类型
}).done(res=> {
    console.log(res)
})
```



### 解决跨域问题

#### JSONP

> 利用script标签不会受到跨域影响的特性。

```js
// 后端
const jsonp = require("koa-jsonp");
app.use(jsonp);

// 前端
$.ajax({
    url: url,
    dataType: "jsonp"
}).done(res=> {
    console.log(res);
})
```



#### 设置服务器响应头信息

```js
router.get("/data", ctx=> {
	ctx.set('Access-Control-Allow-Origin', 'http://127.0.0.1:8080');
    ctx.body = "hello world";
})
```





## MySQL

### 定义数据库

1. `链接数据库: mysql -u root -p`
2. `查看数据库: show databases`
3. `创建数据库: create database dbname`
4. `切换数据库: use dbname`
5. `查看所有表: show tables`
6. `修改数据库: alter database dbname character set utf8`
7. `删除数据库: drop database dbname`



### 数据类型

> int：整形
>
> double：浮点型，double(6,3)，最长长度是6位，小数点后3位，999.999
>
> char：固定长度字符串类型，char(10)，不足10位补足10位，例如身份证。
>
> varchar：可变长度字符串，char(10)，不足10位不会补足，性能低于char，例如个性签名。
>
> text：字符串，适用于大文本内容，例如博客内容。
>
> date：日期类型 yyyy-MM-dd



### 常用命令

1. `创建表: create table tbname(id int, name varchar(20), sex char(1));`
2. `查看表信息: desc tbname;`
3. `查询表数据: select * from tbname;`
4. `插入数据: insert into tbname (id, name, sex) values (1, '小明', 0)`
5. `修改数据: update tbname set name = '小明', age = 2 where id = 3;`
6. `删除数据: delete from tbname where id = 3;`
7. `修改表: alter table tbname add achievement double(5, 2);`
8. `修改表: alter table tbname change name username varchar(20);`
9. `修改表: alter table tbname drop name`
10. `删除表: drop table tbname`



### SQL的分类

> **DDL（Data Definition Language）：数据定义语言，用来操作数据库对象：库、表、列等；**
>
> create、alter、drop；用于数据库创建阶段。
>
> **DML（Data Manipulation Language）：数据操作语言，用来增删改数据库中的数据；**
>
> insert、update、delete；用于系统运行阶段
>
> **DQL（Data Query Language）：数据库查询语句，用来查询数据库中的数据；**
>
> select



### 查询语句

> **select**
>
> 查询所有：select * from tbname;
>
> 查询具体列：select column1, column2... from tbname;
>
> 查询后进行修改（不影响原数据）（as 取别名，可省略）：select column1+18 as ageLater, column2... from tbname;

#### 简单的查询（不影响原数据）

1. `查询所有: select * from tbname;`
2. `查询具体列: select column_1, column_2 from tbname;`
3. `查询后进行修改: select column_1+18, column_2 from tbname;`
4. `查询后设置别名: select column_1+18 as column_3, column from tbname;`
5. `as省略: select column_1+18 column_3, column from tbname;`



#### 按条件查询

1. `where设置条件: select * from tbname where id=1;`
2. `where设置多个条件: select * from tbname where attr_1=80 and attr_2=18;`
3. `大于小于设置: select * from tbname where attr_1>10;`
4. `大于小于同时('<>'为不等于): select * from tbname where attr_1>3 and attr_1<10;`
5. `使用between: select * from tbname where attr_1 between 3 and 10;`
6. `使用is: select * from tbname where attr_1 is NULL;`
7. `使用or: select * from tbname where attr_1=3 or attr_1=10;`
8. `使用in: select * from tbname where attr_1 in (1, 3, 5)`
9. `字段包含x的内容: select * from tbname where sttr_1 like '%x%';('%x'以x结尾的字符串，'x%'以x开头的字符串)`

#### 排序（先写条件，再写排序）

1. `默认升序: select * from tbname ordered by attr_1;`
2. `升序: select * from tbname where attr_1=19 ordered by attr_2 asc;`
3. `降序: select * from tbname ordered by attr_1 desc;`
4. `按两样排序: select * from tbname ordered by attr_1, attr_2 desc;`

#### 常用函数

1. `转换为小写: select attr_1, lower(attr_1) attr_1_lower from tbname;`
2. `转换为大写: select attr_1, upper(attr_1) attr_1_upper from tbname;`
3. `截取字符串(从第5位截2位): select attr_1, substr(attr_1, 5, 2) attr_1_lower from tbname;`
4. `截取字符串用于条件: select attr_1 from tbname where substr(attr_1, 3, 1)='m';`
5. `字符串长度: select attr_1, length(attr_1) attr_1_length from tbname;`
6. `判断null后转换为0: select attr_1, ifnull(attr_1, 0) attr_1_ifnull from tbname;`

#### 聚合函数

1. `总和: select sum(attr_1) from tbname;`
2. `平均: select avg(attr_1) from tbname;`
3. `最大值: select max(attr_1) from tbname;`
4. `最小值: select min(attr_1) from tbname;`
5. `总数量: select count(*) from tbname;`
6. `不为null的数量: select count(attr_1) from tbname;`
7. `带条件的数量: select count(*) from tbname where attr_2=18;`
8. `去掉重复元素: select distinct attr_1 from tbname;`
9. `查询分组后的各个数量: select attr_1 count(*) from tbname group by attr_1;`
10. `分组后查询各组总和: select attr_1 sum(attr_2) from tbname group by attr_1;`
11. `having对分组进行筛选: select attr_1 sum(attr_2) from tbname group by attr_1 having sum(attr_2)>100;`

#### limit关键字

1. `限制个数: select * from tbname limit 5;`
2. `限制具体位置: select * from tbname limit 5, 8;`



#### 查询顺序

> **SELECT xxx FROM xxx WHERE xxx GROUP BY xxx HAVING xxx ORDER BY xxx LIMIT xxx;**



### 约束条件分类

> **非空约束**
>
> `保证字段的值不能为空: attr_1 varchar(20) not null;`
>
> **默认约束**
>
> `保证字段即使不插入数据，也会有一个默认值: attr_1 varchar(20) default '未知';`
>
> **主键约束**
>
> `保证数据不为空且唯一: attr_1 int primary key auto_increment`
>
> **外键约束**
>
> `限制两个表的关系，一个表的外键必须为另一个表的主键，可以为空`
>
> `foreign key(attr_1) references tbname(attr_2);----定义一对多关系`



### 查询扩展

#### 多表查询

> 不推荐方式：`select tbname_1.attr_1, tbname_2.attr_2 from tbname_1, tbname_2 where tbname_1.attr_1=tbname_2.attr_2`
>
> 缩写形式：`select t1.attr_1, t2.attr_2 from tbname_1 t1, tbname_2 t2 where t1.attr_1=t2.attr_2`

#### 链接查询的分类

1. **内连接：获取两个表交集的所有内容**

   `SELECT t1.attr_1, t2.attr_2 FROM tbname_1 t1 INNER JOIN tbname_2 t2 ON t1.attr_1=t2.attr_2;`

2. **左外连接：左表全部+右表对应内容**

   `SELECT t1.attr_1, t2.attr_2 FROM tbname_1 t1 LEFT JOIN tbname_2 t2 ON t1.attr_1=t2.attr_2;`

3. **右外连接：右表全部+左表对应内容**

   `SELECT t1.attr_1, t2.attr_2 FROM tbname_1 t1 LEFT JOIN tbname_2 t2 ON t1.attr_1=t2.attr_2;`



#### 通过关系表查询

多对多的关系

`SELECT t1.attr_1, t2.attr_2 FROM tbname_1_to_tbname_2 t1_2 INNER JOIN tbname_1 t1 ON t1_2.attr_attr3=t1.attr_4 INNER JOIN tbname_2 t2 ON t1_2.attr_5=t2.attr_6`



#### 子查询

找出大于平均值的数据

`SELECT attr_1, attr_2 FROM tbname WHERE attr_2>(SELECT AVG(attr_2) FROM tbname);`values
