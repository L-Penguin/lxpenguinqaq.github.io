### JavaScript

`Object.is(arg_1, arg_2)`这个函数会对两个参数进行比较，如果两者是简单数据类型（string，number， boolean），这会将两者数值进行比较，如果两者是object数据类型，则会对两个参数的地址进行比较。



`JSON.stringify(value[, reolacer[, space]])`

- `value`：将序列化后成JSON字符串的值。
- `replacer`：如果该参数是一个**函数**则在序列化过程中，被序列化的值得每个属性都会经过该函数的转换和处理；如果该参数是一个**数组**，则只有包含在这个数组中的属性名才会被序列化到最终的`JSON`字符串中；如果该参数为`null`或者未提供，则对向所有的属性都会被序列化。
- `space`：指定缩进用的空白字符串，用于美化输出。如果参数是个数字，它代表有多少的空格，上限为10；该值若小于1，则意味着没有空格；如果该参数为字符串（当字符串长度超过10个字母，取其前10个字母），该字符串将被作为空格；如果该参数没有提供（或者为`null`），将没有空格。

```js
const obj = {a: 12, b: {c: {d: 1, e: 2}, f: 3}, g: 4};
function func(key, val) {
    console.log("key: ", key);
    console.log("val: ", val);
    return val;
}
JSON.stringify(obj, func);
/*
    key:  
    val:  {a: 12, b: {…}, g: 4}
    key:  a
    val:  12
    key:  b
    val:  {c: {…}, f: 3}
    key:  c
    val:  {d: 1, e: 2}
    key:  d
    val:  1
    key:  e
    val:  2
    key:  f
    val:  3
    key:  g
	val:  4
*/
function fliter(key, val) {
    if (typeof val === 'number') {
        if (val < 10) {
            return undefined;
        } else {
            return val;
        }
    } else {
        return undefined
    }
}
// "{"a":12,"b":{"c":{}}}"
```



### React

#### `useCallback()`和`useMemo()`区别

> `useCallback`和`useMemo`都会接收两个参数，参数1是函数组件或者普通函数，参数2是一个数组，存放依赖项。
>
> 两者都是用来缓存内容，减少重复创建函数（当函数作为props传递时会造成重新渲染）或者重复渲染组件。
>
> 两者很像，唯一区别是：`useCallback`是根据依赖(deps)缓存第一个入参的(callback)。`useMemo`是根据依赖(deps)缓存第一个入参(callback)执行后的值。
>
> 前者将整个参数1缓存下来，即完全引用；后者将参数1执行后的结果缓存下来。
>
> 第二个参数都是依赖项，只要依赖项不变，则两函数执行的结果不会重新执行。





